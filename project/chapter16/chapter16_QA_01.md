# Chapter 16 Q&A Part 1: スレッドとメッセージパッシング

## Q1: クロージャってなんだっけ？

**質問:** スレッドでクロージャを使うけど、クロージャって何だっけ？

**回答:** **環境の変数をキャプチャできる無名関数**

---

### 基本的な構文

```rust
// 普通の関数
fn add_one(x: i32) -> i32 {
    x + 1
}

// クロージャ
let add_one = |x| x + 1;
```

---

### 一番重要な特徴：環境のキャプチャ

#### 普通の関数：外の変数を使えない
```rust
let y = 10;
fn add(x: i32) -> i32 {
    x + y  // ❌ エラー！
}
```

#### クロージャ：外の変数を使える
```rust
let y = 10;
let add = |x| x + y;  // ✅ OK！

println!("{}", add(5));  // 15
```

---

### スレッドでの使い方

```rust
let v = vec![1, 2, 3];

thread::spawn(|| {  // クロージャ
    println!("ベクタ: {:?}", v);  // v をキャプチャ
});
```

### move キーワード

```rust
let v = vec![1, 2, 3];

thread::spawn(move || {  // move で所有権を奪う
    println!("ベクタ: {:?}", v);
});
// v はもう使えない
```

---

### Python との対応

| Rust | Python |
|------|--------|
| `\|x\| x + 1` | `lambda x: x + 1` |

---

## Q2: move キーワードはなぜ必要？

**質問:** moveキーワードの説明がよくわからない

**回答:** **借用だけだと危険なので、所有権を移動する**

---

### 問題：借用だけだと危険

```rust
let v = vec![1, 2, 3];

thread::spawn(|| {
    println!("{:?}", v);  // v を借用
});

drop(v);  // メインスレッドでvを削除！
// スレッドが実行される時、vは存在しない💥
```

---

### コンパイラが保守的に防ぐ

```
error: closure may outlive the current function, but it borrows `v`
```

**意味:**
- スレッドはメインスレッドより長生きする可能性がある
- 借用だけだと、vが削除されるかもしれない
- だからエラーにする

---

### 解決策：move で所有権を移動

```rust
let v = vec![1, 2, 3];

thread::spawn(move || {  // move!
    println!("{:?}", v);  // v の所有権を奪う
});

// drop(v);  // ❌ エラー！v はもうない
```

**効果:**
- メインスレッドは v を使えない
- スレッドが v を安全に所有
- データ競合を防ぐ

---

### メモリ図

#### 借用の場合（危険）
```
メインスレッド              スレッド
┌─────────┐              ┌─────────┐
│ v       │              │ &v      │ ← 参照だけ
└─────────┘              └─────────┘
     ↓
   drop(v)  ← v が消える

                         ┌─────────┐
                         │ &v ???  │ ← 参照先が消えた！💥
                         └─────────┘
```

#### move の場合（安全）
```
メインスレッド              スレッド
┌─────────┐              ┌─────────┐
│ v       │─────移動────>│ v       │ ← 所有権を奪う
└─────────┘              └─────────┘
     ↓
   もう使えない
```

---

## Q3: recv と try_recv の違いは？

**質問:** recv と try_recv はどう使い分けるの？

**回答:** **他にやることがあるかどうか**

---

### recv: ブロックする（待つ）

```rust
let msg = rx.recv().unwrap();
// メッセージが来るまでずっと待つ⏳
```

**用途:** メッセージを受信すること**だけ**が仕事の場合

---

### try_recv: ブロックしない（すぐ返す）

```rust
match rx.try_recv() {
    Ok(msg) => println!("受信: {}", msg),
    Err(_) => println!("まだメッセージなし"),
}
// すぐに結果を返す
```

**用途:** メッセージを待ちながら**他の作業もしたい**場合

---

### 使い分けの例

#### recv を使う（他にやることがない）
```rust
// メッセージを待つだけ
for received in rx {
    println!("受信: {}", received);
}
```

#### try_recv を使う（他にもやることがある）
```rust
// ゲームループ
loop {
    match rx.try_recv() {
        Ok(msg) => handle_message(msg),
        Err(_) => {},  // メッセージなし
    }

    // ゲームロジック（メッセージがなくても実行）
    update_game();
    render();

    thread::sleep(Duration::from_millis(16)); // 60 FPS
}
```

---

### タイムライン比較

#### recv
```
|--待つ--|--待つ--|--待つ--|メッセージ受信|--待つ--|
         ↑ 何もしない（ブロック）
```

#### try_recv
```
|チェック|作業|チェック|作業|チェック|メッセージ受信|チェック|作業|
   ↓              ↓              ↓
  なし           なし           あった！
```

---

## Q4: tx と rx って何？

**質問:** `let (tx, rx) = mpsc::channel();` って結局何？

**回答:** **tx が入力、rx が出力**

---

### tx = Transmitter（送信機）

```rust
tx.send(data).unwrap();
```
- データを**送る**側
- チャネルに**入力**
- 複数作れる（clone可能）

---

### rx = Receiver（受信機）

```rust
let data = rx.recv().unwrap();
```
- データを**受け取る**側
- チャネルから**出力**
- 1つだけ（cloneできない）

---

### チャネルのイメージ

```
送信側(tx)              チャネル              受信側(rx)
┌────────┐            ┌────────┐           ┌────────┐
│ thread │──send─────>│ ░░░░░░ │──recv───>│  main  │
└────────┘            └────────┘           └────────┘
   入力                  パイプ               出力
```

---

### 水道管のたとえ

```
蛇口(tx)           パイプ            コップ(rx)
  ↓                 ||                  ↑
水を入れる      ─→  ||  ─→         水を受け取る
```

---

## まとめ

| 質問 | 答え |
|------|------|
| クロージャとは？ | 環境をキャプチャできる無名関数 |
| move が必要な理由 | 借用だと危険、所有権を移動して安全に |
| recv vs try_recv | 待つか、すぐ返すか |
| tx と rx | 送信機（入力）と受信機（出力） |
