# Chapter 16 Q&A Part 3: デッドロックと Send/Sync

## Q10: 内部可変性とデッドロックについて

**質問:** counter は不変なのに中身を変更できる？デッドロックって何？

**回答:** **2つの重要なポイントがあります**

---

### ポイント1: 内部可変性

#### counter は不変なのに変更できる

```rust
let counter = Arc::new(Mutex::new(0));
//  ^^^^^^^
//  mut がない！不変

let mut num = counter.lock().unwrap();
*num += 1;  // でも中身を変更できる！
```

**理由:** Mutex が内部可変性を提供（RefCell と同じパターン）

---

#### RefCell との比較

##### RefCell（シングルスレッド）
```rust
let x = RefCell::new(5);  // mut なし
*x.borrow_mut() = 6;      // でも変更できる
```

##### Mutex（マルチスレッド）
```rust
let x = Mutex::new(5);    // mut なし
*x.lock().unwrap() = 6;   // でも変更できる
```

---

### ポイント2: デッドロック

#### デッドロックとは？

**2つのスレッドがお互いのロックを待ち合ってしまう状態**

```rust
let resource1 = Arc::new(Mutex::new(1));
let resource2 = Arc::new(Mutex::new(2));

// スレッド1: A → B の順でロック
// スレッド2: B → A の順でロック
// → デッドロック！💀
```

---

#### デッドロックの流れ

```
時間 →

スレッド1: resource1 をロック 🔓
スレッド2:                        resource2 をロック 🔓

スレッド1:                        resource2 を待つ... ⏳
スレッド2: resource1 を待つ... ⏳

↓ お互いに永遠に待つ（デッドロック）💀
```

---

#### Rust が防げること vs 防げないこと

##### ✅ Rust が防げる（コンパイル時）
- データ競合
- 所有権違反
- ダングリングポインタ

##### ❌ Rust が防げない（実行時）
- デッドロック
- 無限ループ
- ビジネスロジックのバグ

---

#### デッドロックを防ぐ方法

1. **ロックの順序を統一**
   ```rust
   // 全スレッドで A → B の順
   ```

2. **ロックを早く解放**
   ```rust
   {
       let num = counter.lock().unwrap();
       *num += 1;
   }  // すぐに解放
   ```

3. **try_lock を使う**
   ```rust
   match mutex.try_lock() {
       Ok(guard) => { /* ... */ }
       Err(_) => { /* ロック取得失敗 */ }
   }
   ```

---

## Q11: コンパイル時のエラーとロジックエラー

**質問:** コンパイル時のエラーは大丈夫だけど、ロジックは自分で気を付ける必要があるってことで大丈夫？

**回答:** ✅ **完璧な理解です！**

---

### Rust の安全性の境界

#### ✅ Rust が保証してくれる（コンパイル時）

```rust
// データ競合
let mut x = 0;
thread::spawn(|| {
    x += 1;  // ❌ コンパイルエラー
});
```

```rust
// 所有権違反
let v = vec![1, 2, 3];
let a = v;
let b = v;  // ❌ コンパイルエラー
```

---

#### ❌ Rust が保証できない（ロジックエラー）

```rust
// デッドロック
let a = mutex1.lock().unwrap();
let b = mutex2.lock().unwrap();  // デッドロックの可能性
// ✅ コンパイルは通る
```

```rust
// 無限ループ
loop {
    // 終わらない...
}
// ✅ コンパイルは通る
```

---

### 図解

```
┌─────────────────────────────────────┐
│     Rust が保証してくれる範囲       │
├─────────────────────────────────────┤
│ • メモリ安全性                       │
│ • データ競合の防止                   │
│ • 所有権の検証                       │
└─────────────────────────────────────┘
         ↑ コンパイル時

┌─────────────────────────────────────┐
│   あなたが気を付ける必要がある範囲   │
├─────────────────────────────────────┤
│ • デッドロック                       │
│ • 無限ループ                         │
│ • ビジネスロジック                   │
└─────────────────────────────────────┘
         ↑ 実行時
```

---

## Q12: マーカートレイトと Send/Sync

**質問:** マーカートレイトってなんですか？Send と Sync それぞれは何？

**回答:** **メソッドを持たないトレイト、型に印を付けるだけ**

---

### マーカートレイトとは？

```rust
// 普通のトレイト
trait Display {
    fn fmt(&self, f: &mut Formatter) -> Result;
    //  ^^^ メソッドがある
}

// マーカートレイト
trait Send {
    // メソッドがない！
    // 「この型はスレッド間で送れますよ」という印だけ
}
```

---

### Send トレイト

> **所有権をスレッド間で転送できる型**

```rust
// ✅ Send な型
let s = String::from("hello");
thread::spawn(move || {
    println!("{}", s);  // OK
});

// ❌ Send でない型
let x = Rc::new(5);
thread::spawn(move || {
    println!("{}", x);  // エラー
});
```

---

### Sync トレイト

> **複数のスレッドから参照を共有できる型**

```rust
// ✅ Sync な型
let x = 5;
// 複数のスレッドから &i32 でアクセスできる

// ❌ Sync でない型
let x = RefCell::new(5);
// 複数のスレッドから &RefCell でアクセスできない
```

---

### Send vs Sync

| トレイト | 意味 | 例 |
|---------|------|-----|
| **Send** | 所有権を転送できる | String, Vec<T> |
| **Sync** | 参照を共有できる | i32, &str |

---

### よくある型

| 型 | Send | Sync | 理由 |
|----|------|------|------|
| `i32` | ✅ | ✅ | 単純な値 |
| `String` | ✅ | ✅ | 所有権がある |
| **Rc<T>** | ❌ | ❌ | 非スレッド安全 |
| **Arc<T>** | ✅ | ✅ | スレッド安全 |
| `RefCell<T>` | ✅ | ❌ | 借用チェックが非スレッド安全 |
| `Mutex<T>` | ✅ | ✅ | スレッド安全 |

---

### 実用上の知識

#### エラーメッセージを理解する

```rust
let x = Rc::new(5);
thread::spawn(move || {
    println!("{}", x);
});
```

**エラー:**
```
`Rc<i32>` cannot be sent between threads safely
         ^^^^^^^^^^^^^^^^^^^^^^^^
         Send トレイトを実装していない
```

**対処:**
```rust
let x = Arc::new(5);  // Arc に変える
```

---

### 記述する必要はない

**通常は書かない:**
```rust
impl Send for MyStruct { }  // 自動実装される
```

**でも知っておくべき:**
- エラーメッセージを理解できる
- 適切な型を選べる
- 並行性の安全性を理解できる

---

## まとめ

| 質問 | 答え |
|------|------|
| 内部可変性とは | 不変でも中身を変更できる（Mutex、RefCell） |
| デッドロックとは | お互いのロックを待ち合う状態 |
| Rust が防げる | データ競合、所有権違反 |
| Rust が防げない | デッドロック、ロジックエラー |
| マーカートレイト | メソッドを持たないトレイト |
| Send | 所有権を転送できる |
| Sync | 参照を共有できる |
| Rc vs Arc | シングルスレッド vs マルチスレッド |

---

## 重要なポイント

1. **所有権システム**: データ競合をコンパイル時に防ぐ
2. **デッドロック**: 自分で気を付ける必要がある
3. **Send/Sync**: 通常は意識しないが、知っておくべき

**Rust の哲学:**
- コンパイラが防げるもの → 徹底的に防ぐ
- コンパイラが防げないもの → プログラマーの責任

これが「fearless concurrency（恐れるな！並行性）」の意味です！💪
