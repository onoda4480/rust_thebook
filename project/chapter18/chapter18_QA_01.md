# Chapter 18 Q&A Part 1: シャドーイングとスコープ

## Q1: if let のシャドーイングとスコープ

**質問:**
> if let Ok(age) = age の行は、Ok列挙子の中の値を含むシャドーイングされた新しいage変数を導入します。つまり、if age > 30という条件は、そのブロック内に配置する必要があります: これら2つの条件を組み合わせて、if let Ok(age) = age && age > 30とすることはできません。30と比較したいシャドーイングされたageは、波括弧で新しいスコープが始まるまで有効にならないのです。
> どゆこと？

**回答:**

### スコープとシャドーイングのタイミング

新しい変数 `age` は波括弧 `{` の後から有効になるため、`&&` の右側では使えません。

```rust
let age: Result<u8, _> = "34".parse();
//  ^^^ 元のage（Result型）

// ❌ これはできない
if let Ok(age) = age && age > 30 {
//         ^^^   ^^^    ^^^
//         新age  元age  どっち？使えない！
}
```

### なぜできないのか？

**実行の流れ:**
```rust
let age: Result<u8, _> = "34".parse();
//  ^^^ これは Result<u8, _> 型

if let Ok(age) = age && age > 30 {
//         ^^^   ^^^    ^^^
//         |     |      ここで age > 30 を評価したい
//         |     元の age (Result型)
//         新しい age (u8型) ← まだ使えない！
}
```

### 新しい age はいつ有効になる？

```rust
if let Ok(age) = age {
//         ^^^
//         この新しい age は...
    // ← ここから有効！波括弧の中
    println!("{}", age);  // ✅ OK
}
```

### 正しい書き方

**方法1: ネストする**
```rust
let age: Result<u8, _> = "34".parse();

if let Ok(age) = age {
    // ← ここで新しい age が有効になる
    if age > 30 {
        println!("30歳以上です");
    }
}
```

**方法2: match を使う**
```rust
let age: Result<u8, _> = "34".parse();

match age {
    Ok(age) if age > 30 => {
        println!("30歳以上です");
    }
    _ => {}
}
```

### シャドーイングの詳細

```rust
let age: Result<u8, _> = "34".parse();
//  ^^^ age は Result<u8, _> 型

if let Ok(age) = age {
//         ^^^   ^^^
//         |     元の age (Result型)
//         |
//         新しい age (u8型)
//         ← でもまだ有効じゃない！

    // ← ここから新しい age が有効
    println!("{}", age);  // age は u8 型
}

// ← ここでは元の age (Result型) に戻る
```

---

## Q2: if let Ok(age) = age の新しい age はどっち？

**質問:**
> if let Ok(age) = age の新しい ageはOk(age)の方？

**回答:**

**はい、その通りです！**

```rust
if let Ok(age) = age {
//      ^^^^^^   ^^^
//      |        元のage (Result<u8, _>型)
//      |
//      Ok(age) ← この中のageが新しい変数！(u8型)
```

### パターンマッチングの構造

```rust
if let パターン = 値 {
//     ^^^^^^   ^
//     左側     右側
}
```

- **右側（`age`）**: 元の変数（Result型）
- **左側（`Ok(age)`）**: パターン
  - `Ok(...)` の中にマッチする値があれば
  - その中身を新しい変数 `age` として束縛（bind）する

### もっとわかりやすい例

```rust
let result: Result<u8, _> = "34".parse();
//  ^^^^^^ ← 元の変数名

if let Ok(value) = result {
//         ^^^^^   ^^^^^^
//         新変数   元の変数
    println!("{}", value);  // value は 34 (u8型)
}
```

この場合は名前が違うのでわかりやすいですね。

### 同じ名前だとシャドーイング

```rust
let age: Result<u8, _> = "34".parse();
//  ^^^ 元のage

if let Ok(age) = age {
//         ^^^   ^^^
//         |     元のage (Result型)
//         新しいage (u8型)

    // この中では新しいage (u8型) が使える
    println!("{}", age);  // 34
}
```

### 覚え方

```
Ok(新しい変数名) = 元の変数
```

- パターンの中（左側）に書いた変数名が新しい変数
- `=` の右側は元の変数

### 図解

```rust
if let Ok(age) = age {
//      ^^^^^^^^
//      |
//      パターン部分
//      ↓
//      Ok( ← 列挙子
//         age ← 新しい変数を定義
//        )
```

```rust
//         age {  // ← スコープ開始
//         ^^^
//         元のage
//             ↓
//      マッチして中身を取り出す
//             ↓
//         新しいage = 34
```

---

## まとめ

| 質問項目 | キーポイント |
|---------|------------|
| **シャドーイングのタイミング** | 新しい変数は波括弧 `{` の後から有効 |
| **&& との組み合わせ** | できない（新しい変数がまだ有効でない） |
| **正しい書き方** | ネストするか match を使う |
| **新しい変数の位置** | `Ok(age)` の `age` が新しい変数 |
| **パターンの構造** | `パターン = 値` の左側で変数を定義 |

### 重要なポイント

1. `if let Ok(age) = age` の左側の `age` が新しい変数
2. 新しい変数は `{` の後から有効
3. `&&` で条件を組み合わせることはできない
4. 同じ名前を使うとシャドーイング（元の変数が隠される）
