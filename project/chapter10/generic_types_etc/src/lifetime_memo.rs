&i32        // a reference
            // (ただの)参照
&'a i32     // a reference with an explicit lifetime
            // 明示的なライフタイム付きの参照
&'a mut i32 // a mutable reference with an explicit lifetime
            // 明示的なライフタイム付きの可変参照

//ライフタイム省略規則
//関数シグネチャにライフタイム注釈がない場合、
//コンパイラは以下の3つのルールに基づいてライフ
//タイムを推論する
//1. 各引数にそれぞれ異なるライフタイム注
//   釈が与えられていると仮定する
//2. もし引数のうちの1つが&selfまたは&mut self
//   なら、そのライフタイム注釈はすべての
//   戻り値のライフタイム注釈に適用される
//3. もし戻り値にライフタイム注釈が1つだけ
//   なら、その注釈はすべての引数のライフタイム注釈に適用される
//これらのルールにより、多くの場合ライフタイム注釈を省略できる
//例えば、以下の関数シグネチャは
fn first_word(s: &str) -> &str {}
//以下と同じである
fn first_word<'a>(s: &'a str) -> &'a str {} 
//なぜなら、上記の関数シグネチャは
//ライフタイム省略規則の1つ目と3つ目に
//当てはまるからである
//ライフタイム注釈が必要な場合
//ライフタイム注釈が必要な場合もある
//例えば、以下の関数はライフタイム注釈が
//必要である
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
//なぜなら、引数xとyのライフタイムが異なる
//場合があるからである
//この場合、戻り値のライフタイムがどちらに
//依存するのかをコンパイラが判断できない
//ので、ライフタイム注釈を使って明示的に
//示す必要がある