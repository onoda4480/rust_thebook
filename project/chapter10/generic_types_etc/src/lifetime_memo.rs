&i32        // a reference
            // (ただの)参照
&'a i32     // a reference with an explicit lifetime
            // 明示的なライフタイム付きの参照
&'a mut i32 // a mutable reference with an explicit lifetime
            // 明示的なライフタイム付きの可変参照

//ライフタイム省略規則
//関数シグネチャにライフタイム注釈がない場合、
//コンパイラは以下の3つのルールに基づいてライフ
//タイムを推論する
//1. 各引数にそれぞれ異なるライフタイム注
//   釈が与えられていると仮定する
//2. もし引数のうちの1つが&selfまたは&mut self
//   なら、そのライフタイム注釈はすべての
//   戻り値のライフタイム注釈に適用される
//3. もし戻り値にライフタイム注釈が1つだけ
//   なら、その注釈はすべての引数のライフタイム注釈に適用される
//これらのルールにより、多くの場合ライフタイム注釈を省略できる
//例えば、以下の関数シグネチャは
fn first_word(s: &str) -> &str {}
//以下と同じである
fn first_word<'a>(s: &'a str) -> &'a str {} 
//なぜなら、上記の関数シグネチャは
//ライフタイム省略規則の1つ目と3つ目に
//当てはまるからである
//ライフタイム注釈が必要な場合
//ライフタイム注釈が必要な場合もある
//例えば、以下の関数はライフタイム注釈が
//必要である
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
//なぜなら、引数xとyのライフタイムが異なる
//場合があるからである
//この場合、戻り値のライフタイムがどちらに
//依存するのかをコンパイラが判断できない
//ので、ライフタイム注釈を使って明示的に
//示す必要がある

//メソッド定義におけるライフタイム注釈
//唯一の引数がselfへの参照で戻り値がi32という何かへの参照ではないlevelというメソッドを使用します:
impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }
}
//この場合、ライフタイム省略規則の2つ目が
//適用されるので、&selfのライフタイムが
//戻り値に適用される
//しかし、戻り値が参照ではないので、
//ライフタイム注釈は必要ない

//3番目のライフタイム省略規則が適用される例はこちらです:
impl<'a> ImportantExcerpt<'a> {
    fn announce_and_return_part(&self, announcement: &str) -> &str {
        //       "お知らせします: {}"
        println!("Attention please: {}", announcement);
        self.part
    }
}
//「メソッドで複数の参照があっても、戻り値は普通 self から返すから、ライフタイムは &self と同じ」
